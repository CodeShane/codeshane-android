/*
> cd project
> gradle tasks
hello
> gradle -q hello

*/
// Java [Builder] Plugin
// adds lots of tasks;
// gradle build // full build
// src/main/java // production source
// src/test/java // autorun
// src/test/resources // included in the test's classpath
// src/main/resources // included in the JAR file as resources
// build // output
// build/libs // new JAR

// Example Build File
apply plugin: 'java'
apply plugin: 'eclipse'
// > gradle eclipse    //    generates eclipse files

// Override Some "Java Plugin" Properties:
sourceCompatibility = 1.5
version = '1.0'

// Action (closure?)
jar {
	manifest {
		attributes 'Implementation-Title': 'Gradle Quickstart', 'Implementation-Version': version
	}
}

// Find dependencies:
repositories {
	mavenLocal()
	mavenCentral()
}


// Fetch dependencies:
dependencies {
	compile group: 'commons-collections', name: 'commons-collections', version: '3.2'
	testCompile group: 'junit', name: 'junit', version: '4.+'
}

test {
	systemProperties 'property': 'value'
}

uploadArchives {
repositories {
flatDir {
dirs 'repos'
}
}
}

// Gradle Task.
task hello {
	// equiv to "ant target"
	// (Ant Task is a cmd ike javac)
	doLast { // action. is a closure.
		println 'Hello world!'
	}
}

// Gradle Task (shorthand)
task bye << {
	println 'Hello world!'
}

// > gradle -q upper
// Original: mY_nAmE
// Upper case: MY_NAME
task upper << {
String someString = 'mY_nAmE'
println "Original: " + someString
println "Upper case: " + someString.toUpperCase()
}

// output "0 1 2 3"
task count << {
	4.times { print "$it " }
}

// Task-Dependency
task intro(dependsOn: hello) << {
	println "I'm Gradle"
}

// Order-Independent.
// dependsOn sounds like "after _"
task taskX(dependsOn: 'taskY') << {
println 'taskX'
}
task taskY << {
println 'taskY'
}

// dynamic task creation
4.times { counter ->
	task "task$counter" << {
		println "I'm task number $counter"
	}
}

// Accessing a task via API - adding a dependency
4.times { counter ->
	task "task$counter" << {
		println "I'm task number $counter"
	}
}
task0.dependsOn task2, task3

// Accessing a task via API - adding behaviour

/*The calls doFirst and doLast can be executed multiple times. They add an action to the beginning or the
end of the task's actions list. When the task executes, the actions in the action list are executed in order. The <<
operator is simply an alias for doLast*/

task hello << {
println 'Hello Earth'
}
hello.doFirst {
println 'Hello Venus'
}
hello.doLast {
println 'Hello Mars'
}
hello << {
println 'Hello Jupiter'
}

// Accessing task as a property of the build script

task hello << {
println 'Hello world!'
}
hello.doLast {
println "Greetings from the $hello.name task."
}

// Adding extra properties to a task
task myTask {
	ext.myProperty = "myValue"
}
task printTaskProperties << {
	println myTask.myProperty
}

// Using AntBuilder to execute ant.loadfile target
task loadfile << {
def files = file('../antLoadfileResources').listFiles().sort()
files.each { File file ->
if (file.isFile()) {
ant.loadfile(srcFile: file, property: file.name)
println " *** $file.name ***"
println "${ant.properties[file.name]}"
}
}
}


// Using methods to organize your build logic

task checksum << {
fileList('../antLoadfileResources').each {File file ->
ant.checksum(file: file, property: "cs_$file.name")
println "$file.name Checksum: ${ant.properties["cs_$file.name"]}"
}
}
task loadfile << {
fileList('../antLoadfileResources').each {File file ->
ant.loadfile(srcFile: file, property: file.name)
println "I'm fond of $file.name"
}
}
File[] fileList(String dir) {
file(dir).listFiles({file -> file.isFile() } as FileFilter).sort()
}

// Defining default task(s)
/*This is equivalent to running gradle clean run. In a multi-project build every subproject can have its own
specific default tasks. If a subproject does not specify default tasks, the default tasks of the parent project are
used (if defined).*/
defaultTasks 'clean', 'run'
task clean << {
println 'Default Cleaning!'
}
task run << {
println 'Default Running!'
}
task other << {
println "I'm not a default task!"
}

// Configure by DAG

/*As we describe in full detail later (See Chapter 54, The Build Lifecycle) Gradle has a configuration phase and an
execution phase. After the configuration phase Gradle knows all tasks that should be executed. Gradle offers
you a hook to make use of this information. A use-case for this would be to check if the release task is part of
the tasks to be executed. Depending on this you can assign different values to some variables.
In the following example, execution of distribution and release tasks results in different value of version
variable.*/

task distribution << {
println "We build the zip with version=$version"
}
task release(dependsOn: 'distribution') << {
println 'We release now'
}
gradle.taskGraph.whenReady {taskGraph ->
if (taskGraph.hasTask(release)) {
version = '1.0'
} else {
version = '1.0-SNAPSHOT'
}
}

/*Output of gradle -q distribution
> gradle -q distribution
We build the zip with version=1.0-SNAPSHOT
Output of gradle -q release
> gradle -q release
We build the zip with version=1.0
We release now
The important thing is, that the fact that the release task has been chosen, has an effect before the release task
gets executed. Nor has the release task to be the primary task (i.e. the task passed to the gradle command).*/



//Some other useful tasks are:
//clean
//Deletes the build directory, removing all built files.
//assemble
//Compiles and jars your code, but does not run the unit tests. Other plugins add more artifacts to this task.
//For example, if you use the War plugin, this task will also build the WAR file for your project.
//check
//Compiles and tests your code. Other plugins add more checks to this task. For example, if you use the
//Code-quality plugin, this task will also run Checkstyle against your source code


External dependencies
Usually, a Java project will have some dependencies on external JAR files. To reference these JAR files in the
project, you need to tell Gradle where to find them. In Gradle, artifacts such as JAR files, are located in a
. A repository can be used for fetching the dependencies of a project, or for publishing repository the artifacts of
a project, or both. For this example, we will use the public Maven repository:
Example 7.3. Adding Maven repository
build.gradle
repositories {
mavenCentral()
}
Let's add some dependencies. Here, we will declare that our production classes have a compile-time dependency
on commons collections, and that our test classes have a compile-time dependency on junit:
Example 7.4. Adding dependencies
build.gradle
dependencies {
compile group: 'commons-collections', name: 'commons-collections', version: '3.2'
testCompile group: 'junit', name: 'junit', version: '4.+'
}



Customising the project
Plugins can add properties (with default values) to your project.

Here we will specify the version number for our Java project, along with the Java version our source is written in. We also add some attributes to the JAR manifest.

// Customization of MANIFEST.MF
build.gradle
sourceCompatibility = 1.5
version = '1.0'
jar {
manifest {
attributes 'Implementation-Title': 'Gradle Quickstart', 'Implementation-Version': version
}
}

Page 42 of 394
> gradle properties  ||  Lists the properties of a project, including those added by plugins and their default values.

The tasks which the Java plugin adds are regular tasks, exactly the
same as if they were declared in the build file. This means you can
use any of the mechanisms shown in earlier chapters to customise
these tasks. For example, you can set the properties of a task, add
behaviour to a task, change the dependencies of a task, or replace a
task entirely. In our sample, we will configure the test task,
which is of type Test, to add a system property when the tests are
executed:
Example 7.6. Adding a test system property
build.gradle
test {
systemProperties 'property': 'value'
}


// publish to the web, or in this case, a local folder
// > gradle uploadArchives
uploadArchives {
repositories {
flatDir {
dirs 'repos'
}
}
}
